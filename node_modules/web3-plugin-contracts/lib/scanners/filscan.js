"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilScanClient = void 0;
const solidity_1 = require("../solidity");
const base_1 = require("./base");
const explorer_service_1 = require("./explorer-service");
class FilScanClient extends base_1.BaseScan {
    constructor(chainId, apiKey) {
        super(chainId, apiKey);
    }
    getSourceCodeEndpoint(address) {
        return `api/v1/contract/${address}`;
    }
    async getSourceCode(address) {
        const apiUrl = this.getsourcecodeURL(address);
        if (!apiUrl) {
            return (0, explorer_service_1.generateSourceCodeError)("API Endpoint not found");
        }
        const response = await fetch(apiUrl);
        if (!response || !response.ok) {
            return (0, explorer_service_1.generateSourceCodeError)("Error fetching contract");
        }
        return await this.convert(await response.json(), address);
    }
    async convert(data, address) {
        if (data.code !== 0 || !data.data) {
            return {
                status: "0",
                message: "NOTOK",
                result: data.message || "Error loading contract",
            };
        }
        let results = this.generateDefaultResult();
        let sourceInput = {
            sources: {},
        };
        if (!data.data.source_codes || data.data.source_codes.length === 0) {
            return {
                status: "1",
                message: "OK",
                result: [results],
            };
        }
        sourceInput.sources = await this.fetchSources(data.data.source_codes);
        const metadata = JSON.parse(data.data.metadata);
        if (metadata.sources) {
            results.SourceCode = `{${JSON.stringify(sourceInput)}}`;
            results.ABI = solidity_1.metadataLib.abi(metadata);
            results.Language = solidity_1.metadataLib.language(metadata);
            results.ContractName = this.appendExtension(solidity_1.metadataLib.contractName(metadata));
            results.CompilerVersion = this.formatVersion(solidity_1.metadataLib.compilerVersion(metadata));
            sourceInput.settings = solidity_1.metadataLib.settings(metadata);
            return {
                status: "1",
                message: "OK",
                result: [results],
            };
        }
        return (0, explorer_service_1.generateSourceCodeError)("Error loading contract");
    }
    async fetchSources(files) {
        const fileContentDict = {};
        await Promise.all(files.map(async (file) => {
            try {
                const response = await fetch(file.code);
                if (response.ok) {
                    const content = await response.text();
                    fileContentDict[file.file_name] = { content };
                }
                else {
                    console.error(`Failed to fetch ${file.file_name}. Status: ${response.status}`);
                }
            }
            catch (error) {
                console.error(`Error fetching ${file.file_name}: ${error}`);
            }
        }));
        return fileContentDict;
    }
}
exports.FilScanClient = FilScanClient;
//# sourceMappingURL=filscan.js.map