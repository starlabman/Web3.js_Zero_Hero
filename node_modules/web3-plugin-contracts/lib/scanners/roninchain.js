"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoninChainClient = void 0;
const path_1 = __importDefault(require("path"));
const solidity_1 = require("../solidity");
const base_1 = require("./base");
const explorer_service_1 = require("./explorer-service");
class RoninChainClient extends base_1.BaseScan {
    constructor(chainId, apiKey) {
        super(chainId, apiKey);
        this.apiUrl = "https://explorer-kintsugi.roninchain.com/v2";
    }
    getSourceCodeEndpoint(address) {
        return `v2/${this.chainId}/contract/${address}/src`;
    }
    async getProxy(address) {
        const response = await fetch(`${this.apiUrl}/${this.chainId}/contract/${address}`);
        if (!response.ok) {
            return "";
        }
        const data = await response.json();
        if (data.message === "ok") {
            return data.result?.proxy_to || "";
        }
        return "";
    }
    async getSourceCode(address) {
        address = await this.getProxy(address) || address;
        const apiUrl = this.getsourcecodeURL(address);
        if (!apiUrl) {
            return (0, explorer_service_1.generateSourceCodeError)("API Endpoint not found");
        }
        const response = await fetch(apiUrl);
        if (!response || !response.ok) {
            return (0, explorer_service_1.generateSourceCodeError)("Error fetching contract");
        }
        return await this.convert(await response.json(), address);
    }
    async convert(data, address) {
        if (data.message !== "ok" || !data.result) {
            return (0, explorer_service_1.generateSourceCodeError)(data.message || "Error loading contract");
        }
        let results = this.generateDefaultResult();
        let sourceInput = {
            sources: {},
        };
        (data.result || []).forEach((element) => {
            sourceInput.sources[element.name] = {
                content: element.content,
            };
        });
        const metadataResponse = await fetch(`${this.apiUrl}/${this.chainId}/contract/${address}/metadata`);
        if (metadataResponse.ok) {
            const metadata = await metadataResponse.json();
            if (metadata.message !== "ok" || !metadata.result) {
                return (0, explorer_service_1.generateSourceCodeError)("Error loading metadata");
            }
            if (metadata.result.settings) {
                if (metadata.result.settings.compilationTarget) {
                    results.ContractName = this.appendExtension(solidity_1.metadataLib.contractName(metadata.result));
                    const absoluteContract = results.ContractName;
                    const resolver = new RoninFileResolver(sourceInput.sources);
                    const resolvedSources = await resolver.getSources(sourceInput.sources[absoluteContract].content, results.ContractName);
                    const baseContent = sourceInput.sources[absoluteContract].content;
                    sourceInput.sources = resolvedSources;
                    sourceInput.sources[results.ContractName] = {
                        content: baseContent,
                    };
                }
                sourceInput.settings = solidity_1.metadataLib.settings(metadata.result);
            }
            results.Language = solidity_1.metadataLib.language(metadata.result);
            results.CompilerVersion = this.formatVersion(solidity_1.metadataLib.compilerVersion(metadata));
        }
        results.SourceCode = `{${JSON.stringify(sourceInput)}}`;
        const metadataABI = await fetch(`${this.apiUrl}/${this.chainId}/contract/${address}/abi`);
        if (metadataABI.ok) {
            const metadata = await metadataABI.json();
            if (metadata.message === "ok" && metadata.result) {
                results.ABI = JSON.stringify(metadata.result?.output?.abi);
            }
        }
        return {
            status: "1",
            message: "OK",
            result: [results],
        };
    }
}
exports.RoninChainClient = RoninChainClient;
class RoninFileResolver {
    constructor(files) {
        this.files = files;
    }
    async getSources(base = "", path = "") {
        let sources = {};
        let dependencies = [];
        try {
            dependencies = await this.extractImports(base, path, []);
            dependencies.forEach((dependency) => {
                const { paths, originalContents } = dependency;
                sources[paths.filePath] = { content: originalContents };
            });
            return sources;
        }
        catch (error) {
            console.log(error);
            return {};
        }
    }
    async extractImports(content, mainPath = "", libraries = []) {
        const regex = /import\s+{([^}]+)}\s+from\s+[""'']([^""'']+)[""'']|import\s+[""'']([^""'']+)[""''];/g;
        const matches = [];
        let match;
        while ((match = regex.exec(content)) !== null) {
            const [, aliasList, filePathWithAlias, filePathWithoutAlias] = match;
            const contractPath = new solidity_1.ContractPaths(filePathWithAlias || filePathWithoutAlias, mainPath);
            if (libraries.includes(contractPath.filePath)) {
                continue;
            }
            libraries.push(contractPath.filePath.toString());
            const { fileContents } = await this.resolve(contractPath.filePath);
            matches.push({
                paths: contractPath,
                fileContents: fileContents,
                originalContents: fileContents,
            });
            matches.push(...(await this.extractImports(fileContents, contractPath.filePath, libraries)));
        }
        return matches;
    }
    async resolve(filePath) {
        const parsedPath = path_1.default.basename(filePath);
        const fileContents = this.files[parsedPath]?.content || "";
        return { fileContents };
    }
}
//# sourceMappingURL=roninchain.js.map