"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainLensClient = void 0;
const solidity_1 = require("../solidity");
const base_1 = require("./base");
const explorer_service_1 = require("./explorer-service");
class ChainLensClient extends base_1.BaseScan {
    constructor(chainId) {
        super(chainId);
    }
    getSourceCodeEndpoint(address) {
        return `${address}`;
    }
    async getSourceCode(address) {
        const apiUrl = this.getsourcecodeURL(address);
        if (!apiUrl) {
            return (0, explorer_service_1.generateSourceCodeError)("API Endpoint not found");
        }
        const response = await fetch(apiUrl);
        if (!response || !response.ok) {
            return (0, explorer_service_1.generateSourceCodeError)("Error fetching contract");
        }
        return await this.convert(await response.json(), address);
    }
    async convert(data, address) {
        if (data.error || data.message) {
            return (0, explorer_service_1.generateSourceCodeError)(data.message);
        }
        data = data;
        let results = this.generateDefaultResult();
        let sourceInput = {
            sources: {},
        };
        data.files
            .filter((file) => file.name.endsWith(".sol"))
            .forEach((file) => {
            const contractAddress = file.path.indexOf('0x');
            const parts = file.path.substring(contractAddress);
            const paths = parts.split('/').slice(2);
            const contractPath = paths.join('/');
            sourceInput.sources[contractPath || file.path] = {
                content: file.content,
            };
        });
        results.SourceCode = `{${JSON.stringify(sourceInput)}}`;
        const metadataFile = data.files.filter((file) => file.name === "metadata.json")[0];
        if (metadataFile) {
            const metadata = JSON.parse(metadataFile.content);
            if (!results.ContractName) {
                results.ContractName = solidity_1.metadataLib.contractName(metadata);
            }
            results.ContractName = this.appendExtension(results.ContractName);
            results.Language = solidity_1.metadataLib.language(metadata);
            results.CompilerVersion = this.formatVersion(solidity_1.metadataLib.compilerVersion(metadata));
            results.ABI = solidity_1.metadataLib.abi(metadata);
        }
        return {
            status: "1",
            message: "OK",
            result: [results],
        };
    }
}
exports.ChainLensClient = ChainLensClient;
//# sourceMappingURL=chain-lens.js.map