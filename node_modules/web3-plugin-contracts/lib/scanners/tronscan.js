"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TronScanClient = exports.isTronAddress = void 0;
const solidity_1 = require("../solidity");
const base_1 = require("./base");
const explorer_service_1 = require("./explorer-service");
const isTronAddress = (address) => address.substring(0, 1) === "T" && address.length === 34;
exports.isTronAddress = isTronAddress;
class TronScanClient extends base_1.BaseScan {
    constructor(chainId, apiKey) {
        super(chainId);
        this.headers = new Headers();
        this.headers.append("Content-Type", "application/json");
    }
    getSourceCodeEndpoint(address) {
        return ``;
    }
    async getSourceCode(address) {
        const apiUrl = this.getsourcecodeURL(address);
        if (!apiUrl) {
            return (0, explorer_service_1.generateSourceCodeError)("API Endpoint not found");
        }
        var body = JSON.stringify({ contractAddress: address });
        var requestOptions = {
            method: "POST",
            headers: this.headers,
            body: body,
            redirect: "follow",
        };
        const response = await fetch(apiUrl, requestOptions);
        if (!response || !response.ok) {
            return (0, explorer_service_1.generateSourceCodeError)("Error fetching contract");
        }
        return await this.convert(await response.json(), address);
    }
    isTronAddress(address) {
        return (0, exports.isTronAddress)(address);
    }
    async convert(data, address) {
        if (data.errmsg || !data.data) {
            return (0, explorer_service_1.generateSourceCodeError)(data.errmsg || "Error loading contract");
        }
        let results = this.generateDefaultResult();
        let sourceInput = {
            sources: {},
        };
        (data.data?.contract_code || []).forEach((element) => {
            sourceInput.sources[element.name] = {
                content: atob(element.code),
            };
        });
        results.SourceCode = `{${JSON.stringify(sourceInput)}}`;
        results.ABI = data.data.abi || "";
        results.OptimizationUsed = data.data.optimizer || "0";
        results.Runs = data.data.optimizer_runs || "0";
        results.LicenseType = data.data.license || "0";
        results.ContractName = data.data.contract_name || "";
        const match = (data.data.compiler || "").match(/tron-(\d+\.\d+\.\d+)/);
        const versionNumber = match ? match[1] : null;
        if (versionNumber) {
            const compilerVersion = solidity_1.compilerVersions.find((element) => element.includes(versionNumber));
            results.CompilerVersion = compilerVersion || solidity_1.solcVersion;
        }
        results.ContractName = this.appendExtension(results.ContractName);
        return {
            status: "1",
            message: "OK",
            result: [results],
        };
    }
}
exports.TronScanClient = TronScanClient;
//# sourceMappingURL=tronscan.js.map