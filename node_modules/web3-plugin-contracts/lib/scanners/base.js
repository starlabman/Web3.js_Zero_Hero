"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseScan = void 0;
const chains_1 = require("../chains");
const web3_validator_1 = require("web3-validator");
const explorer_service_1 = require("./explorer-service");
const solidity_1 = require("../solidity");
class BaseScan {
    constructor(chainId, apiKey) {
        this.appendExtension = (payload, extension = ".sol") => {
            if (!payload.endsWith(extension)) {
                return payload.concat(extension);
            }
            return payload;
        };
        this.formatVersion = (version) => {
            if (version) {
                const compilerVersion = solidity_1.compilerVersions.find((i) => i.includes(version));
                return compilerVersion || solidity_1.solcVersion;
            }
            return solidity_1.solcVersion;
        };
        this.generateDefaultResult = () => {
            return {
                SourceCode: "",
                ABI: "",
                ContractName: "",
                CompilerVersion: solidity_1.solcVersion,
                OptimizationUsed: "0",
                Runs: "200",
                ConstructorArguments: "",
                EVMVersion: "default",
                Library: "",
                LicenseType: "0",
                Proxy: "",
                Implementation: "",
                SwarmSource: "",
            };
        };
        this.chainId = chainId;
        this.apiKey = apiKey || "";
    }
    getSourceCodeEndpoint(address) {
        return `api?module=contract&action=getsourcecode&address=${address}`;
    }
    getsourcecodeURL(address) {
        const apiUrl = (0, chains_1.getAPI)(this.chainId);
        if (!apiUrl) {
            return "";
        }
        let uri = `${apiUrl}/${this.getSourceCodeEndpoint(address)}`;
        if (this.apiKey) {
            uri = uri.concat(`&apikey=${this.apiKey}`);
        }
        return uri;
    }
    async call(address) {
        const apiUrl = this.getsourcecodeURL(address);
        if (!apiUrl) {
            return (0, explorer_service_1.generateSourceCodeError)("API Endpoint not found");
        }
        const response = await fetch(apiUrl);
        if (!response || !response.ok) {
            return (0, explorer_service_1.generateSourceCodeError)("Error fetching contract");
        }
        let data = (await response.json());
        return data;
    }
    async getSourceCode(address) {
        let data = await this.call(address);
        if (data.status === "0") {
            return data;
        }
        const result = data.result[0];
        if ((0, web3_validator_1.isAddress)(result.Implementation)) {
            data = await this.call(result.Implementation);
        }
        return data;
    }
    async metadataGetSources(metadata) {
        let sources = {};
        let fileUrls = {};
        if (metadata.sources) {
            Object.entries(metadata.sources).forEach(([key, val]) => {
                if (val.urls) {
                    const ipfsFile = val.urls.find((element) => element.includes("ipfs")) || "";
                    const cidV0 = /Qm[1-9A-HJ-NP-Za-km-z]{44,}/;
                    const extractedCID = ipfsFile.match(cidV0);
                    if (!extractedCID) {
                        throw new Error("Sorry the contract is not supported yet.");
                    }
                    fileUrls[`https://api.universalprofile.cloud/ipfs/${extractedCID[0]}`] = key;
                }
            });
            const fetchData = (url) => {
                return (fetch(url)
                    .then((response) => response.text())
                    .then((content) => {
                    if (content.trim() === "Not Found") {
                        console.log(`${fileUrls[url]} not found`);
                    }
                    return [url, content];
                })
                    .catch((error) => console.error("Error fetching data:", error)));
            };
            const dataArray = await Promise.all(Object.keys(fileUrls).map((url) => fetchData(url)));
            dataArray.forEach((element) => {
                sources[fileUrls[element[0]]] = {
                    content: element[1],
                };
            });
        }
        return sources;
    }
}
exports.BaseScan = BaseScan;
//# sourceMappingURL=base.js.map