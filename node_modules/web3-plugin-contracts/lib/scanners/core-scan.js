"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoreScanClient = void 0;
const base_1 = require("./base");
const explorer_service_1 = require("./explorer-service");
const chains_1 = require("../chains");
const solidity_1 = require("../solidity");
class CoreScanClient extends base_1.BaseScan {
    constructor(chainId, apiKey) {
        super(chainId, apiKey);
    }
    getSourceCodeEndpoint(address) {
        return `/api/chain/abi`;
    }
    async call(address) {
        const apiUrl = this.getsourcecodeURL(address);
        if (!apiUrl) {
            return (0, explorer_service_1.generateSourceCodeError)("API Endpoint not found");
        }
        const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                contractAddress: address,
            }),
        });
        if (!response || !response.ok) {
            return (0, explorer_service_1.generateSourceCodeError)("Error fetching contract");
        }
        return await response.json();
    }
    async getSourceCode(address) {
        let data = await this.call(address);
        if (data.data?.isProxy) {
            data = await this.call(data.data?.logicAddress || address);
        }
        return await this.convert(data, address);
    }
    async convert(data, address) {
        if (!data.data.id || !data.data.source) {
            return {
                status: "0",
                message: "NOTOK",
                result: data.message || "Error loading contract",
            };
        }
        const contractName = this.appendExtension(data.data?.contractName);
        let results = this.generateDefaultResult();
        let sourceInput = {
            sources: {},
        };
        await Promise.all(data.data.source.map(async (element) => {
            if (!element.name) {
                element.name = contractName;
                const response = await fetch(`${(0, chains_1.getAPI)(this.chainId)}${element.path}`);
                if (!response || !response.ok) {
                    return;
                }
                sourceInput.sources[element.name] = {
                    content: await response.text(),
                };
            }
            else {
                const response = await fetch(`${(0, chains_1.getAPI)(this.chainId)}${element.path}`);
                if (!response || !response.ok) {
                    return;
                }
                const metadata = await response.json();
                sourceInput.sources = {
                    ...metadata.sources || {}
                };
            }
        }));
        results.SourceCode = `{${JSON.stringify(sourceInput)}}`;
        results.ABI = data.data?.abi || "[]";
        results.Language = "Solidity";
        results.ContractName = contractName;
        results.CompilerVersion = data.data?.compilerVersion || solidity_1.solcVersion;
        results.OptimizationUsed = data.data?.optimization ? "1" : "0";
        results.Runs = data.data?.optimizeRuns ? data.data.optimizeRuns : "200";
        return {
            status: "1",
            message: "OK",
            result: [results],
        };
    }
}
exports.CoreScanClient = CoreScanClient;
//# sourceMappingURL=core-scan.js.map